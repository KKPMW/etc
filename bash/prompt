#!/usr/bin/env bash
# Sexy bash prompt by twolfson
# https://github.com/twolfson/sexy-bash-prompt
# Forked from gf3, https://gist.github.com/gf3/306785
# Simplified by Karolis Koncevicius

function get_git_branch() {
  # On branches, this will return the branch name
  # On non-branches, (no branch)
  ref="$(git symbolic-ref HEAD 2> /dev/null | sed -e 's/refs\/heads\///')"
  if [[ "$ref" != "" ]]; then
    echo "$ref"
  else
    echo "(no branch)"
  fi
}

is_branch1_behind_branch2 () {

  # Find the first log (if any) that is in branch1 but not branch2
  first_log="$(git log $1..$2 -1 2> /dev/null)"

  # Exit with 0 if there is a first log, 1 if there is not
  [[ -n "$first_log" ]]
}

branch_exists () {
  # List remote branches           | # Find our branch and exit with 0 or 1 if found/not found
  git branch --remote 2> /dev/null | grep --quiet "$1"
}

parse_git_ahead () {
  # Grab the local and remote branch
  branch="$(get_git_branch)"
  remote_branch="origin/$branch"

  # If the remote branch is behind the local branch
  # or it has not been merged into origin (remote branch doesn't exist)
  if (is_branch1_behind_branch2 "$remote_branch" "$branch" ||
      ! branch_exists "$remote_branch"); then
    # echo our character
    echo 1
  fi
}

parse_git_behind () {
  # Grab the branch
  branch="$(get_git_branch)"
  remote_branch="origin/$branch"

  # If the local branch is behind the remote branch
  if is_branch1_behind_branch2 "$branch" "$remote_branch"; then
    # echo our character
    echo 1
  fi
}

function parse_git_dirty() {
  # If the git status has *any* changes (e.g. dirty), echo our character
  if [[ -n "$(git status --porcelain 2> /dev/null)" ]]; then
    echo 1
  fi
}

function is_on_git() {
  git rev-parse 2> /dev/null
}

function get_git_status() {
  # Grab the git dirty and git behind
  dirty_branch="$(parse_git_dirty)"
  branch_ahead="$(parse_git_ahead)"
  branch_behind="$(parse_git_behind)"

  # Iterate through all the cases and if it matches, then echo
  if [[ "$dirty_branch" == 1 && "$branch_ahead" == 1 && "$branch_behind" == 1 ]]; then
    echo "⬢" # unpulled + unpused + dirty
  elif [[ "$branch_ahead" == 1 && "$branch_behind" == 1 ]]; then
    echo "⬡" # unpulled + unpushed
  elif [[ "$dirty_branch" == 1 && "$branch_ahead" == 1 ]]; then
    echo "▲" # unpushed + dirty
  elif [[ "$branch_ahead" == 1 ]]; then
    echo "△" # unpushed
  elif [[ "$dirty_branch" == 1 && "$branch_behind" == 1 ]]; then
    echo "▼" # unpulled + dirty
  elif [[ "$branch_behind" == 1 ]]; then
    echo "▽" # unpulled
  elif [[ "$dirty_branch" == 1 ]]; then
    echo "*" # dirty
  else # clean
    echo "" # synced
  fi
}

get_git_info () {
  branch="$(get_git_branch)"

  if [[ "$branch" != "" ]]; then
    output="$branch"
    echo "$output"
  fi
}

PS1="\
\$(is_on_git && \
  echo -n \"\[\033[38;5;8m\]\$(get_git_info)\" && \
  echo -n \"\[\033[38;5;1m\]\$(get_git_status) \")\
\[\033[1;38;5;0m\]:: \[\033[00m\]"

PS2="\
\$(is_on_git && \
  echo -n \"\[\033[38;5;8m\]\$(get_git_info)\" && \
  echo -n \"\[\033[38;5;1m\]\$(get_git_status) \")\
\[\033[1;38;5;0m\]++ \[\033[00m\]"
